-- Script generated by Lokasenna's GUI Builder

--[[
*
* This script converts an envelope curve to a cc curve, preserving point shape!
* there are many things that could be optimized, but feature creep has already
* gotten the best of me so I'm gonna call it for now.
*
* POTENTIAL BUG: ClearCCLane will grab the last touched cc lane, which is not necessarilly
*                still the one shown in the GUI. if a user hits Get CC Lane and then touches
*                another one before hitting Go, then the other cc lane will be cleared, and
*                not the one shown in the gui.
*
--]]

local lib_path = reaper.GetExtState("Lokasenna_GUI", "lib_path_v2")
if not lib_path or lib_path == "" then
    reaper.MB("Couldn't load the Lokasenna_GUI library. Please install 'Lokasenna's GUI library v2 for Lua', available on ReaPack, then run the 'Set Lokasenna_GUI v2 library path.lua' script in your Action List.", "Whoops!", 0)
    return
end
loadfile(lib_path .. "Core.lua")()




GUI.req("Classes/Class - Label.lua")()
GUI.req("Classes/Class - Options.lua")()
GUI.req("Classes/Class - Button.lua")()
GUI.req("Classes/Class - Textbox.lua")()
-- If any of the requested libraries weren't found, abort the script.
if missing_lib then return 0 end



GUI.name = "Convert Envelope to CC"
GUI.x, GUI.y, GUI.w, GUI.h = 0, 0, 640, 576
GUI.anchor, GUI.corner = "mouse", "C"


-- constants. I feel like there might be a better way to go about this.
MAX_FADER_VALUE = reaper.ScaleToEnvelopeMode(1, 2.0)
CENTER_FADER_VALUE = reaper.ScaleToEnvelopeMode(1, 1.0)
MIN_DB = -150
MAX_DB = reaper.SLIDER2DB(MAX_FADER_VALUE)
CENTER_DB = 0
MAX_CC_7 = 127  -- all control changes use this one pretty much
MAX_CC_14 = 16383 -- pitch uses this, and any 14 bit cc's but I won't bother with those.

-- other globals: ENVELOPE, MIDI_EDITOR, ACTIVE_TAKE, CHANMSG, MSG2_IN, CHAN

-- ================================================================== MAIN ======================================================================

function Main()

  -- get gui values
  local timeSelect = GUI.Val("Bounds")
  local clearExistingCC = GUI.Val("Clear_Existing_CC")
  local scaleOrSlideOption = GUI.Val("Scaling_Options")
  local faderScaleOption = GUI.Val("Fader_Options")
  local centerValues = GUI.Val("Center_Values")
  
  
  if not MIDI_EDITOR or not ACTIVE_TAKE or not ENVELOPE then return end
  
  reaper.Undo_BeginBlock()
  
  reaper.Main_OnCommand(40331, 0) -- unselect all envelope points
  reaper.MIDIEditor_OnCommand(MIDI_EDITOR, 40214)  -- unselect all events
  
  
  local pitch
  
  if CHANMSG == 224 then
    pitch = true
  else
    pitch = false
  end
  
  
  if timeSelect == 1 then
    reaper.Main_OnCommand(40330, 0) -- select all points in time selection
  else
    reaper.Main_OnCommand(40332, 0) -- select all points
  end
  
  if clearExistingCC then
    if timeSelect == 1 then
      ClearCCLane(MIDI_EDITOR, true)
    else
      ClearCCLane(MIDI_EDITOR, false)
    end
  end
  

  -- ======================= convert envelope points to cc points ==============================
  -- ton of variables
  local ccMax
  local envMax, envMin, envCenter, faderScaled
  local time, value, shape, sel
  local tension, ccShape, ccTime, ccValue = {}, {}, {}, {}
  local valueIn, maxIn, minIn, centerIn
  local currentMax, currentMin = -1, 16384
  local addedPnts = 0
  
  if pitch then
    ccMax = MAX_CC_14
  else
    ccMax = MAX_CC_7
  end
  
  local numPoints = reaper.CountEnvelopePoints(ENVELOPE)
  
  for i = 0, numPoints - 1 do
    
    envMin, envMax, envCenter, faderScaled = GetEnvScaleInfo(ENVELOPE)
    _, time, value, shape, tension[addedPnts], sel = reaper.GetEnvelopePoint(ENVELOPE, i)
      
    if sel then
    
      if faderScaled then
      
        if faderScaleOption == 1 then -- linear
        
          valueIn = value; minIn = 0; maxIn = MAX_FADER_VALUE 
          if centerValues then centerIn = CENTER_FADER_VALUE end
          
        elseif faderScaleOption == 2 then -- logarithmic
        
          valueIn = reaper.SLIDER2DB(value); minIn = MIN_DB; maxIn = MAX_DB;
          if centerValues then centerIn = CENTER_DB end
          if valueIn < -150 then valueIn = -150 end -- doing this because the two lowest db envelope values are -150, then -inf. -inf gets mapped to -1000 which screws up the scaling.
          
        elseif faderScaleOption == 3 then -- exponential
        
          valueIn = reaper.ScaleFromEnvelopeMode(1, value); minIn = envMin; maxIn = envMax;
          if centerValues then centrIn = envCenter end
          
        end
      
      -- if not fader scaled
      else
      
        valueIn = value; minIn = envMin; maxIn = envMax;
        if centerValues then centerIn = envCenter end
        
      end
      
      
      ccValue[addedPnts] = Env2CC(valueIn, minIn, maxIn, ccMax, centerIn)
      
      ccShape[addedPnts] = EnvShape2CCShape(shape)
      
      ccTime[addedPnts] = reaper.MIDI_GetPPQPosFromProjTime(ACTIVE_TAKE, time)
      
      if ccValue[addedPnts] < currentMin then currentMin = ccValue[addedPnts] end
      if ccValue[addedPnts] > currentMax then currentMax = ccValue[addedPnts] end
      
      addedPnts = addedPnts + 1
      
    end
    
  end
  
  -- ========================== scale points based on option, then insert them =====================
  -- we need a 2nd loop, because we need to know the min/max point vals in order to do scaling.
  
  local scaledCC
  local msg2Out, msg3Out  -- these aren't actually out parameters
  
  for i = 0, addedPnts - 1 do
    
    if scaleOrSlideOption == 1 then -- we don't want to do any scaling. we could check this before and then skip this loop entirely.
      scaledCC = ccValue[i]
      
    elseif scaleOrSlideOption == 2 then -- scale to fitrange
      scaledCC = Env2CC(ccValue[i], currentMin, currentMax, ccMax)
      
    elseif scaleOrSlideOption == 3 then -- scale to fit range around center
      scaledCC = Env2CC(ccValue[i], currentMin, currentMax, ccMax, math.ceil(ccMax / 2))
      
    elseif scaleOrSlideOption == 4 then -- slide values up to max
      scaledCC = ccValue[i] + (ccMax - currentMax)
      
    elseif scaleOrSlideOption == 5 then -- slide values down to min
      scaledCC = ccValue[i] - currentMin
      
    end
    
    if pitch then
      msg2Out, msg3Out = RawCC2Pitch(scaledCC)
    else
      msg2Out = MSG2_IN
      msg3Out = scaledCC
    end
    
    
    local okay = reaper.MIDI_InsertCC(ACTIVE_TAKE, true, false, ccTime[i], CHANMSG, CHAN, msg2Out, msg3Out)
        
    if not okay then
      reaper.ShowConsoleMsg("unable to insert point: " .. i .. " time: " .. time .. " value: " .. value .. "\n")
    end
    
  end
  
  -- =========================== set shape =================================
  -- we need a 3rd loop here because all MIDI_InsertCC doesn't have a shape argument, so we have to set it afterwards.
  
  local notecnt, ccevtcnt, textsyxcnt
  _, notecnt, ccevtcnt, textsyxcnt = reaper.MIDI_CountEvts(ACTIVE_TAKE)
  
  local count = 0
  
  for i = 0, ccevtcnt - 1 do
    
    -- see if the point is selected
    local _, ccSel, _, _, _, _, _, _ = reaper.MIDI_GetCC(ACTIVE_TAKE, i)
    
    
    if ccSel then 
      
      local okay = reaper.MIDI_SetCCShape(ACTIVE_TAKE, i, ccShape[count], tension[count], true)
    
      if not okay then
        reaper.ShowConsoleMsg("Unable to set point: " .. i)
      end
    
      count = count + 1
     
    end
    
  end
  
  reaper.MIDI_Sort(ACTIVE_TAKE)  -- we need to do this at the end, since we were setting multiple points at once.

  
  reaper.Undo_EndBlock("convert envelope to cc", 0)
end

-- ==================================================================== HELPERS ==================================================================

-- sets the global variables MIDI_EDITOR, ACTIVE_TAKE, CHANMSG, MSG2_IN, CHAN
function GetCCLane()

  -- get the active midi editor
  MIDI_EDITOR = reaper.MIDIEditor_GetActive()
  
  if not MIDI_EDITOR then
    reaper.ShowMessageBox("failed to get active midi editor. make sure one is open and a cc lane has been touched.", "Error", 0)
    return
  end
  
  -- get the last clicked cc lane
  local laneInt = reaper.MIDIEditor_GetSetting_int(MIDI_EDITOR, "last_clicked_cc_lane")
  
  if not laneInt then
    reaper.ShowMessageBox("failed to get last touched cc lane. make sure one has been touched.", "Error", 0)
    return
  end
  
  -- get a whole bunch of other info to display nicely. I AM ASSUMING that the rest of these functions will work.
  local _, laneString = reaper.MIDIEditor_GetSetting_str(MIDI_EDITOR, "last_clicked_cc_lane", "")
  
  ACTIVE_TAKE = reaper.MIDIEditor_GetTake(MIDI_EDITOR)
  CHAN = reaper.MIDIEditor_GetSetting_int(MIDI_EDITOR, "default_note_chan")
  local takeName = reaper.GetTakeName(ACTIVE_TAKE)
  local takeNumber = reaper.GetMediaItemTakeInfo_Value(ACTIVE_TAKE, "IP_TAKENUMBER")
  local trackPtr = reaper.GetMediaItemTakeInfo_Value(ACTIVE_TAKE, "P_TRACK")
  local _, trackName = reaper.GetTrackName(trackPtr)
  
  
  
  -- check to see if the lane is one I want to support (cc 0-119 and pitch)
  if (laneInt >= 0) and (laneInt <= 127) then
    CHANMSG = 176 
    MSG2_IN = laneInt
  elseif laneInt == 513 then  -- this is pitch. this 513 is actually a decimal representation of 0x201. kinda yucky.
    CHANMSG = 224
    MSG2_IN = 0
  else
    reaper.ShowMessageBox("Failed to get last touched cc lane. This app only supports cc 0-119 and pitch\n", "Error", 0)
    return
  end
  
  if string.len(takeName) > 10 then
    takeName = string.sub(takeName, 0, 8) .. ("...")
  end
  
  -- show the last touched cc lane and info about track, take, etc.
  GUI.Val("CC_Lane", trackName .. " " .. takeName .. " take " .. 
    math.floor(takeNumber + 1) .. ": " .. laneString .. " channel " .. CHAN + 1)
  
end


-- sets global variable: ENVELOPE
function GetSelectedEnvelope()
  ENVELOPE = reaper.GetSelectedEnvelope(0)
  
  if ENVELOPE == nil then
    reaper.ShowMessageBox("Could not get selected envelope. make sure one is selected.\n", "Error", 0)
    return
  end
  
  local _, envName = reaper.GetEnvelopeName(ENVELOPE)
  local track= reaper.Envelope_GetParentTrack(ENVELOPE)
  local _, trackName = reaper.GetTrackName(track)
  
  GUI.Val("Envelope", trackName .. " " .. envName)
  

end


-- returns envelope min, max, center, and whether it is fader scaled.
function GetEnvScaleInfo(envelope)
  local br_env = reaper.BR_EnvAlloc(envelope, false)
  
  local _, _, _, _, _, _, minValue, maxValue, centerValue,
      _, faderScaling, _ = reaper.BR_EnvGetProperties(br_env)
      
  reaper.BR_EnvFree(envelope, false)
  
  return minValue, maxValue, centerValue, faderScaling
  
end
  

-- clears last touched ccLane
function ClearCCLane(midiEditor, timeSelect)
  
  if timeSelect then
    reaper.MIDIEditor_OnCommand(midiEditor, 40747) -- select all points in time selection.
    -- this won't work if user clicks on another cc lane before clicking go. i don't know what to do about it.
  else
    reaper.MIDIEditor_OnCommand(midiEditor, 40668) -- select all points in last clicked ccLane
  end
    
  reaper.MIDIEditor_OnCommand(midiEditor, 40667) -- delete points
  
end


-- scales values from range(min1, max1) into range(min2, max2) if Env2CC is the meat n potatoes, this is the bread and butter.
function Scale2Range(val, min1, max1, min2, max2)

  local rangeIn = max1 - min1
  local rangeOut = max2 - min2
  local ratio = (val - min1)/rangeIn
  local offset = ratio * rangeOut
  local scaledValue = offset + min2
  
  return scaledValue
  
end


-- this function is the meat and potatoes.
-- perhaps i should rename this, its more general than just envelope points to cc, and I don't always use it for just that.
function Env2CC(envValue, min, max, ccMax, --[[optional]]center)
  
  local ccValue
  
  -- if the min value is < 0 (looking at you pan envelope), scale it so everythings positive :)
  if min < 0 then
    local offset = min * -1
    min = 0
    max = max + offset
    envValue = envValue + offset
    if center then center = center + offset end
  end
  

  if not center then
    ccValue = Scale2Range(envValue, min, max, 0, ccMax)
  
  else
    -- if the center is half of the max (then the center doesn't even matter)
    if center == (max / 2) then
      ccValue = Scale2Range(envValue, min, max, 0, ccMax)
    
    else
      
      if envValue <= center then
        ccValue = Scale2Range(envValue, min, center, 0, math.ceil(ccMax / 2))
        
      else
        ccValue = Scale2Range(envValue, center, max, math.ceil(ccMax / 2), ccMax)
      
      end
    end
  end
  
  return math.floor(ccValue + 0.5)
  
end


-- this function converts a value from 0 - 16383 int midi msg3 (coarse) and msg2 (fine)
function RawCC2Pitch(rawCC)
  local msg2, msg3
  
  msg3 = math.floor(rawCC / 128)
  
  msg2 = rawCC % 128
  
  return msg2, msg3
  
end


-- I have to make this because apparently, square is shape 0 for midi, but linear is shape 0 for envelopes.
-- those two are switched. the rest are the same.
function EnvShape2CCShape(envShape)
  if envShape == 0 then
    return 1
  elseif envShape == 1 then
    return 0
  else
    return envShape
  end
end


-- ====================================================================== GUI ====================================================================

GUI.New("Env_Label", "Label", {
    z = 11,
    x = 32,
    y = 32,
    caption = "Envelope to convert:",
    font = 2,
    color = "txt",
    bg = "wnd_bg",
    shadow = true
})

GUI.New("Envelope", "Textbox", {
    z = 11,
    x = 32,
    y = 64,
    w = 448,
    h = 20,
    caption = "",
    cap_pos = "left",
    font_a = 3,
    font_b = "monospace",
    color = "txt",
    bg = "wnd_bg",
    shadow = true,
    pad = 4,
    undo_limit = 20
})

GUI.New("Get_Env", "Button", {
    z = 11,
    x = 512,
    y = 64,
    w = 76,
    h = 24,
    caption = "Get Envelope",
    font = 3,
    col_txt = "txt",
    col_fill = "elm_frame",
    func = GetSelectedEnvelope
})

GUI.New("CC_Label", "Label", {
    z = 11,
    x = 32,
    y = 96,
    caption = "CC lane to convert to (last touched):",
    font = 2,
    color = "txt",
    bg = "wnd_bg",
    shadow = true
})

GUI.New("CC_Lane", "Textbox", {
    z = 11,
    x = 32,
    y = 128,
    w = 448,
    h = 20,
    caption = "",
    cap_pos = "left",
    font_a = 3,
    font_b = "monospace",
    color = "txt",
    bg = "wnd_bg",
    shadow = true,
    pad = 4,
    undo_limit = 20
})

GUI.New("Get_CC", "Button", {
    z = 11,
    x = 512,
    y = 128,
    w = 76,
    h = 24,
    caption = "Get CC Lane",
    font = 3,
    col_txt = "txt",
    col_fill = "elm_frame",
    func = GetCCLane
})

GUI.New("Bounds", "Radio", {
    z = 11,
    x = 32,
    y = 192,
    w = 128,
    h = 68,
    caption = "Bounds",
    optarray = {"Time selection", " Entire track"},
    dir = "v",
    font_a = 2,
    font_b = 3,
    col_txt = "txt",
    col_fill = "elm_fill",
    bg = "wnd_bg",
    frame = true,
    shadow = true,
    swap = nil,
    opt_size = 20
})

GUI.New("Clear_Existing_CC", "Checklist", {
    z = 11,
    x = 32,
    y = 290,
    w = 192,
    h = 32,
    caption = "",
    optarray = {"Clear existing CC events"},
    dir = "v",
    pad = 4,
    font_a = 2,
    font_b = 3,
    col_txt = "txt",
    col_fill = "elm_fill",
    bg = "wnd_bg",
    frame = false,
    shadow = true,
    swap = nil,
    opt_size = 20
})

GUI.New("Scaling_Options", "Radio", {
    z = 11,
    x = 320,
    y = 192,
    w = 264,
    h = 142,
    caption = "Scaling Options",
    optarray = {"No scaling", "Scale to use full CC range", "Scale to use full range (around CC center)", "Slide values up to max", "Slide values down to min"},
    dir = "v",
    font_a = 2,
    font_b = 3,
    col_txt = "txt",
    col_fill = "elm_fill",
    bg = "wnd_bg",
    frame = true,
    shadow = true,
    swap = nil,
    opt_size = 20
})

GUI.New("Advanced_Label", "Label", {
    z = 11,
    x = 32,
    y = 368,
    caption = "Advanced Options (honestly don't bother):",
    font = 2,
    color = "txt",
    bg = "wnd_bg",
    shadow = true
})

GUI.New("Fader_Options", "Radio", {
    z = 11,
    x = 32,
    y = 400,
    w = 192,
    h = 88,
    caption = "For fader scaled envelopes:",
    optarray = {"Use fader value", "Use dB value", "Use envelope value"},
    dir = "v",
    font_a = 2,
    font_b = 3,
    col_txt = "txt",
    col_fill = "elm_fill",
    bg = "wnd_bg",
    frame = true,
    shadow = true,
    swap = nil,
    opt_size = 20
})

GUI.New("Center_Values", "Checklist", {
    z = 11,
    x = 32,
    y = 512,
    w = 96,
    h = 32,
    caption = "",
    optarray = {"Use envelope center when converting"},
    dir = "v",
    pad = 4,
    font_a = 2,
    font_b = 3,
    col_txt = "txt",
    col_fill = "elm_fill",
    bg = "wnd_bg",
    frame = false,
    shadow = true,
    swap = nil,
    opt_size = 20
})

GUI.New("Go", "Button", {
    z = 11,
    x = 460,
    y = 416,
    w = 128,
    h = 128,
    caption = "Go!!",
    font = 3,
    col_txt = "white",
    col_fill = "green",
    func = Main
})

GUI.Val("Clear_Existing_CC", true) -- makes this option checked by default, I don't know another way to do this.

GUI.Init()
GUI.Main()
